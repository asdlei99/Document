# Linux命令行参数处理

## getopt

```c
       #include <unistd.h>

       int getopt(int argc, char * const argv[],
                  const char *optstring);

       extern char *optarg;
       extern int optind, opterr, optopt;
```

### 描述

getopt解析命令行参数。它的参数argc和argv是在程序调用时传递给main（）函数的参数计数和数组。

参数argc它是程序启动时传递给main（）函数的参数。argc为传入程序的参数的个数，默认为1，代表程序自身。

参数argv是程序启动时传递给main（）函数的参数。argv是一个指针数组，用来存放命令行参数。传入的命令行参数以空白符（包括空格符，制表符，换行符）分界，并以字符串的形式存放在指针数组argv中，argv数组的每个元素存放一个字符串指针，指向一个传入的命令行参数。

以`-`（而不是"_“）开头的argv元素就是一个**选项元素**。“-”叫做**选项标识符**。选项标识符后面可以紧跟一个字符，这个字符叫做**选项字符**。选项字符后面可以紧跟一个或多个字符，这些字符叫做**选项参数**。

也就是说一个选项元素包括选项标识符、选项字符、选项参数三部分，其中选项字符和选项的参数是可选的，如果有选项字符则必须紧跟在标识符后，选项参数根据规则不同可以紧跟在标识符后面，也可以与选项字符用空白符分开。如：命令行"app.exe -abc -d"，此时argc为3，argv[0]为“app.exe”，**argv[1] 为 “-abc”**，argv[2] 为 “-d”。**其中“a”是第一个选项字符，“bc”为选项参数**，“d”是第二选项字符，没有选项参数。**如果重复调用getopt（），它依次返回每个选项元素的选项字符。在前面的例子中第一次返回“a”，第二次返回“d”。**


**默认情况下，getopt（）在每次调用时会重新排列argv数组中除了argv[0]之外的元素，最终这些元素中所有既不是选项（无论合不合法）也不是选项参数的元素都会排到argv数组末尾。**这样argv数组中除argv[0]之外的元素分为与选项有关和与选项无关两类。但类内元素的相对顺序并不会变。



### 规则

- 如果选项字符后跟一个冒号，就表示这个选项后面必须带有参数（没有带选项参数会报错，然后将optarg置为null，optopt置为该选项字符，且返回’?’），getopt将指向同一个选项元素中的选项参数或下一个argv元素的指针放入optarg中，也就是说这个参数可以和选项连在一起写（此时optarg指向同一个同一个选项元素中的选项参数），也可以用空白符隔开（此时optarg指向下一个argv元素），比如app.exe -a123和app.exe -a 123（中间有空格）都表示123是-a的参数。特别地，如果漏写选项参数，且它不是最后一个argv元素，则无论下一个元素是什么都将视为该选项字符的选项参数。
- **如果选项字符后跟两个冒号**，就表示这个选项可以有参数，也可以没有参数，但要注意有参数时，**选项字符与选项参数之间不能有空格**（若有空格，则认为该选项不带参数），这一点和一个冒号时是有区别的。这是一个GNU才有的扩展功能。
- **不带冒号**的表示这个选项没有参数。如果命令行参数中此选项字符之后紧跟其他字符，则会被作为选项字符处理。